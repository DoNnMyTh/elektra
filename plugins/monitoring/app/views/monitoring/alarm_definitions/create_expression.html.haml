= content_for :title do
  Alarm Definition Step #{@step_count}

.modal-body
  %h4 Create Expression #{@step_count}
  %p.alert.alert-error.create-expression-error
  .row
    .col-md-11
    .col-md-1
  .row
    .col-md-11
      = label_tag 'expression_preview', 'Preview', class:'control-label'
      .panel.panel-default
        .panel-body.panel-expression
          .row
            .col-md-11
              = form_tag "", method: :post,  id:'expression' do
                = hidden_field_tag 'expressions'
                
              - index = 0;
              - @sub_expressions.each do |expression, logical_operator|
                .sub-expression.text-success
                  - index += 1
                  = expression+logical_operator
                  = icon( 'trash', class: 'delete-expression', title: 'remove expresssion from chain', onclick: '$(this).parent().fadeOut(100).remove();')
              #expression_preview
            .col-md-1
              .loading_place.loading-right
    .col-md-1.reset-btn
      - if modal?
        = link_to "Reset", plugin('monitoring').create_expression_alarm_definitions_path(), class: 'btn btn-default', title: 'this will reload everything', data: { modal:true }
      - else
        = link_to "Reset", plugin('monitoring').create_expression_alarm_definitions_path(), class: 'btn btn-default', title: 'this will reload everything'
  .row
    .col-md-6
      .form-group
        = label_tag 'metric', 'Metric', class:'control-label'
        = text_field_tag 'metric', nil, class: 'form-control metric', data: { provide: "typeahead" }, placeholder: "cpu.idle_perc"
        %span.help-block
          A metric is uniquely identified by a name and set of dimensions.
      #expression_dimensions
      .form-group
        = label_tag 'statistical_function', 'Statistical Function', class: 'control-label'
        %select#statistical_function.form-control{onchange: 'monitoring.generate_expression();'}
          %option{value: 'avg'} avg
          %option{value: 'min'} min
          %option{value: 'max'} max
          %option{value: 'sum'} sum
          %option{value: 'count'} count
      .form-group.period
        = label_tag 'period', 'Period', class: 'control-label'
        .row
          .col-md-3
            = text_field_tag 'period_custom', 60, class: 'form-control', onchange: 'monitoring.generate_expression();'
          .col-md-9.period-slider
            -# note: we need the style tag here to render the slide in correct size (css class is not working)
            = text_field_tag 'period_slider', nil, type: 'text', style: 'width:95%;' ,class: 'form-control'
        %span.help-block.period
          Period is the number of seconds for the measurement to be done on. It must be an integer multiple of 60. The default period is 60 seconds.
      .form-group.threshold
        .row 
          .col-md-2
            = label_tag 'threshold_relational_operator', 'Threshold', class: 'control-label'
            %select#threshold_relational_operator.form-control{onchange: 'monitoring.generate_expression();'}
              %option{value: '<'} <
              %option{value: '>'} >
              %option{value: '<='} <=
              %option{value: '>='} >=
          .col-md-10
            = label_tag 'threshold_value', 'Value', class: 'control-label'
            = text_field_tag 'threshold_value', 60, class: 'form-control', onchange: 'monitoring.generate_expression();'
        %span.help-block.threshold
          Threshold values are always in the same units as the metric that they are being compared to.
      = label_tag 'chain_operator', 'Chain Operator*', class: 'control-label'
      %select#chain_operator.form-control{onchange: 'monitoring.generate_expression();'}
        %option
        %option{value: 'AND'} and
        %option{value: 'OR'} or
      %span.help-block
        Chain expressions with logical operators together (optional).

    .col-md-6

.buttons{ class: modal? ? 'modal-footer' : '' }
  - if modal?
    %button.btn.btn-default{ type: 'button', data: { dismiss: 'modal' }, aria: { label: 'Cancel' } }
      Cancel
  - else
    = link_to "Cancel", plugin('monitoring').alarm_definitions_path(), class: 'btn btn-default'
  
  -# TODO: modal test
  = link_to "Chain Another Expression", "#", id: 'chain_expression_btn', class: 'btn btn-primary disabled', onclick: "$('form#expression').submit()"
  = link_to "Create Definition", plugin('monitoring').new_alarm_definition_path(), id: 'create_alarm_definition_btn', class: 'btn btn-primary disabled', data: { modal:true }  

  
:javascript

  // all metric names
  var metric_names = #{@metric_names.to_json};
  // global dimension counter
  var dimension_cnt = 0;

  $('#period_slider').slider({
    step: 60,
    min: 60,
    max: 600,
    value:60,
    formatter: function(value) {
      return value+' sec';
    }
  }).on(
    "slide", function(slide_event) { 
       //console.log(slide_event.value);
       monitoring.generate_expression();
       $('#period_custom').val(slide_event.value);
    }
  );
  
  $(function(){
    // set typeahead for metrics
    $("#metric").typeahead({ source:  metric_names, afterSelect: 
      function(){ 
        // this is called once to get the dimension data
        get_dimensions($('#metric').val());
        // cleanup everything
        dimension_cnt = 1;
        $('#expression_dimensions').empty();
        $('.expression_dimension_head').css('display','inline');
        // render the row based on dimension_data and the template
        render_dimension_row(dimension_cnt);
      }
    });
    // initial autofocus
    setTimeout(function() {
      $("#metric").focus().select();
      monitoring.generate_expression();
    }, 0);
  });

  function render_dimension_row(ID) {
    // if no dimension was found do nothing
    if (dimension_data) {
      var dimension_keys = Object.keys(dimension_data);
      $.post( "#{plugin('monitoring').dimension_row_alarm_definitions_path()}", {cnt: ID, keys: JSON.stringify(dimension_keys)}, 
        function( data ){ 
          // render row data
          $('#expression_dimensions').append(data);
          autocomplete_dimension_values(ID);
      });
    }
  }
  
  function autocomplete_dimension_values(ID) {
    // destroy old typeahead
    $("#dimension_value_"+ID).typeahead('destroy');
    // get typeahead data
    var selected_dimension_key = $("#dimension_key_"+ID).val();
    var dimension_values = dimension_data[selected_dimension_key];
    // set typeahead for values
    $("#dimension_value_"+ID).typeahead({ source: dimension_values, afterSelect: 
      function(){
        // remove selected value from array
        var selected_dimension_value = $("#dimension_value_"+ID).val();
        var value_index =  dimension_data[selected_dimension_key].indexOf(selected_dimension_value);
        // console.log(value_index);
        dimension_data[selected_dimension_key].splice(value_index,1);
        // remove key if no values left
        if ( dimension_data[selected_dimension_key].length == 0 ) {
          delete dimension_data[selected_dimension_key];
        }
        // render new row
        dimension_cnt++
        render_dimension_row(dimension_cnt); 
        monitoring.generate_expression();
        // made row read only
        $("#dimension_value_"+ID).prop("readonly", true);
        //$("#dimension_key_"+ID).prop("readonly", true);
        $("#dimension_key_"+ID).prop("disabled", "disabled");
      }
    });
    // set fokus to value field
    $("#dimension_value_"+ID).focus();
    
    var id_before = ID - 1;
    // console.log(id_before);
    if($('#expression_remove_dimension_btn_'+id_before)) {
      $('#expression_remove_dimension_btn_'+id_before).removeClass('disabled');
    }
  }

  // we used here a global value because it is used by render_dimension_row that and
  // dimension_data is only generated once
  var dimension_data;
  function get_dimensions(METRIC_NAME) {
    $.ajax({
      url: "#{plugin('monitoring').dimensions_by_metric_alarm_definitions_path()}",
      data: { name: METRIC_NAME },
      success: function( data ) { 
        dimension_data = data; 
        // normalize data
        $(Object.keys(dimension_data)).each(function(index,dimension_key) {
          //console.log(dimension_key);
          var unique_values = [];
          // removed doubled entrys
          // http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array
          $.each(dimension_data[dimension_key], function(i, value){
              if($.inArray(value, unique_values) === -1) unique_values.push(value);
          });
          dimension_data[dimension_key] = unique_values;
        })
      },
      error: function(jqXHR) {
        $('.create-expression-error').css('display','block');
        $('.create-expression-error').html('Metric Dimensions Error: '+jqXHR.status+' '+jqXHR.statusText);
      },
      // async false because I need the dimension_data in any case first
      async: false
    });
  }
  
  
